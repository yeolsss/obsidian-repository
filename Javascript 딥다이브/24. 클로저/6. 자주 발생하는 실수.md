아래는 클로저를 사용할 대 자주 발생할 수 있는 실수를 보여주는 예제다.

```javascript
var funcs = [];  
  
for (var i = 0; i < 3; i++) {  
  funcs[i] = function () {return i}; // ⓵  
}  
  
for (var j = 0; j < funcs.length; j++) {  
  console.log(funcs[j]()); // ⓶  
}
```

첫 번째 for 문의 코드 블록 내(⓵)에서 함수가 funcs 배열의 요소로 추가된다. 그리고 두 번째 for 문의 코드 블록 내(⓶)에서 funcs 배열의 요소로 추가된 함수를 순차적으로 호출한다. 이때 funxs 배열의 요소로 추가된 3개의 함수가 0, 1, 2를 반환할 것으로 기대했었다면 아쉽지만 결과는 그렇지 않다.

for 문의 변수 선언문에서 var 키워드로 선언한 i 변수는 블록 레벨 스코프가 아닌 함수 레벨 스코프를 갖기 때문에 전역 변수다. 전역 변수 i에는 0, 1, 2가 순차적으로 할당된다. 따러서 funcs 배열의 요소로 추가한 함수를 호출하면 전역 변수 i를 참조하여 i의 값 3이 출력된다.

클로저를 사용해 위 예제를 바르게 동작하는 코드로 만들어보자.

```javascript
var funcs = [];  
  
for (var i = 0; i < 3; i++) {  
  funcs[i] = (function (id) { // ⓵  
    return function () {  
      return id;  
    };  
  }(i));  
}  
  
for (var j = 0; j < funcs.length; j++) {  
  console.log(funcs[j]);  
}
```

⓵에서 즉시 실행 함수는 전역 변수 i에 현재 할당되어 있는 값을 인수로 전달받아ㅏ 매개변수 id에 할당한 후 중첩 함수를 반환하고 종료된다. 즉시 실행 함수가 반환하는 함수는 funcs 배열에 순차적으로 저장된다.

이때 즉시 실행 함수의 매개변수 id는 즉시 실행 함수가 반환한 중첩 함수의 상위 스코프에 존재한다. 즉시 실행 함수가 반환한 중첩 함수는 자신의 상위 스코프(즉시 실행 함수의 렉시컬 환경)를 기억하는 클로저이고, 매개변수 id는 즉시 실행 함수가 반환한 중첩 함수에 묶여있는 자유 변수가 되어 그 값이 유지된다.

위 예제는 자바스크립트의 함수 레벨 스코프 특성으로 인해 for문의 변수 선언문에서 var 키워드로 선언한 변수가 전역 변수가 되기 때문에 발생하는 현상이다. ES6의 let 키워드를 사용하면 이 같은 번거로움이 깔끔하게 해결된다.

```javascript
const funcs = [];  
  
for (let i = 0; i < 3; i++) {  
  funcs[i] = function () {   return i; };  
}  
  
for (let i = 0; i < funcs.length; i++) {  
  console.log(funcs[i]); // 0 1 2  
}
```

for 문의 변수 선언문에서 let 키워드로 선언한 변수를 사용하면 for 문의 코드 블록이 반복 실행될 때마다 for 문 코드 블록의 새로운 렉시컬 환경이 생성된다. 만약 for문의 코드 블록 내에서 정의한 함수가 있다면 이 함수의 상위 스코프는 for 문의 코드 블록이 반복 실행될 때마다 생성된 for 문 코드 블록의 새로운 렉시컬 환경이다.

이때 함수의 상위 스코프는 for 문의 코드 블록이 반복 실행될 때마다 식별자(for 문의 변수 선언문에서 선언한 초기화 변수 및 for 문의 코드 블록 내에서 선언한 지역 변수 등)의 값을 유지해야 한다. 이를 위해 for문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다.

![[Screen Shot 2023-10-10 at 8.10.14 PM.png]]

⓵ for 문의 변수 선언문에서 let 키워드로 선언한 초기화 변수를 사용한 for문이 평가되면 먼저 새로운 렉시컬 환경<sup>LOOP Lexical Environment</sup>을 생성하고 초기화 변수 식별자와 값을 등록한다. 그리고 새롭게 생성된 렉시컬 환경을 현재 실행 중인 실행 컨텍스트의 렉시컬 환경으로 교체한다.

⓶, ⓷, ⓸ for 문의 코드 블록이 반복 실행되기 시작하면 새로운 렉시컬 환경을 생성하고 for문 코드 블록 내의 식별자와 값(증감문 반영 이전)을 등록한다. 그리고 새롭게 생성된 렉시컬 환경을 현재 실행 중인 실행 컨텍스트의 렉시컬 환경으로 교체한다.

⓹ for 문의 코드 블록의 반복 실행이 모두 종료되면 for문이 실행되기 이전의 렉시컬 환경을 실행 중인 실행 컨텍스트의 렉시컬 환경으로 되돌린다.

이처럼 let이나 const 키워드를 사용하는 반복문(for 문, for ... in 문, for ... of 문, while 문 등)은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시 상태를 마치 스냅숏을 찍는 것처럼 저장한다. 단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.

또 다른 방법으로 함수형 프로그래밍 기법인 고차 함수를 사용하는 방법이 있다. 이 방법은 변수와 반복문의 사용을 억제할 수 있기 때문에 오류를 줄이고 가독성을 좋게 만든다. 다음 예제에는 아직 살펴보지 않은 내용이 포함되어 있으므로 또 다른 방법이 있다는 것만 참고로 알아두자.

```javascript
// 요소가 3개인 배열을 생성하고 배열의 인덱스를 반환하는 함수를 요소로 추가한다.  
// 배열의 요소로 추가된 함수들은 모두 클로저다.  
const funcs = Array.from(new Array(3), (_, i) => () => i); //?  
  
// 배열의 요소로 추가된 함수들을 순차적으로 호출한다.  
funcs.forEach(f => console.log(f())); // 0 1 2
```