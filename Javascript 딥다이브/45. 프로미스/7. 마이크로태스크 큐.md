다음 예제가 어떤 순서로 로그가 출력될지 생각해 보자.

```javascript
setTimeout(() => console.log(1), 0);  
  
Promise.resolve()  
.then(() => console.log(2))  
.then(() => console.log(3));  
// 2  
// 3  
// 1
```

프로미스의 후속 처리 메서드도 비동기로 동작하므로 1 -> 2 -> 3의 순으로 출력될 것처럼 보이지만 2 -> 3 -> 1의 순서로 출력된다. 그 이유는 프로미스의 후속 처리 메서드의 콜백 함수는 태스크 큐가 아니라 마이크로 태스크 큐<sup>microtask queue/job queue</sup>에 저장되기 때문이다.

마이크로태스크 큐는 태스크 큐와는 별도의 큐이다. 마이크로태스크 큐에는 프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장된다. 그 외의 비동기 함수의 콜백 함수나 이벤트 핸들러는 태스크 큐에 일시 저장된다.

콜백 함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 **마이크로태스크 큐는 태스크큐보다 우선순위가 높다.** 즉, 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 가져와 실행한다. 이후 마이크로태스크 큐가 비면 태스크 큐에서 대기하고 잇는 함수를 가져와 실행한다.
